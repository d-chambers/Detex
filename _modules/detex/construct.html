
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>detex.construct &#8212; detex __version__ = 1.0.9 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for detex.construct</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Thu Oct 29 18:39:50 2015</span>

<span class="sd">@author: derrick</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># python 2 and 3 compatibility imports</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">with_statement</span><span class="p">,</span> <span class="n">nested_scopes</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">obspy</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="k">import</span> <span class="n">linkage</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="k">import</span> <span class="n">string_types</span>

<span class="kn">import</span> <span class="nn">detex</span>

<span class="n">pd</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">chained_assignment</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># mute setting copy warning</span>


<span class="c1">################ CLUSTERING FUNCTIONS AND CLASSES  ################</span>

<div class="viewcode-block" id="createCluster"><a class="viewcode-back" href="../../detex.html#detex.construct.createCluster">[docs]</a><span class="k">def</span> <span class="nf">createCluster</span><span class="p">(</span><span class="n">CCreq</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                  <span class="n">fetch_arg</span><span class="o">=</span><span class="s1">&#39;EventWaveForms&#39;</span><span class="p">,</span>
                  <span class="n">filt</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span>
                  <span class="n">stationKey</span><span class="o">=</span><span class="s1">&#39;StationKey.csv&#39;</span><span class="p">,</span>
                  <span class="n">templateKey</span><span class="o">=</span><span class="s1">&#39;TemplateKey.csv&#39;</span><span class="p">,</span>
                  <span class="n">trim</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">120</span><span class="p">],</span>
                  <span class="n">saveclust</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">fileName</span><span class="o">=</span><span class="s1">&#39;clust.pkl&#39;</span><span class="p">,</span>
                  <span class="n">decimate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;double&#39;</span><span class="p">,</span>
                  <span class="n">eventsOnAllStations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">enforceOrigin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">fillZeros</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">phases</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Function to create an instance of the ClusterStream class </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    -------</span>
<span class="sd">    CCreq : float, between 0 and 1</span>
<span class="sd">        The minimum correlation coefficient for grouping waveforms. </span>
<span class="sd">        0.0 results in all waveforms grouping together and 1.0 will not</span>
<span class="sd">        form any groups.</span>
<span class="sd">    fetch_arg : str or detex.getdata.DataFetcher instance</span>
<span class="sd">        Fetch_arg of detex.getdata.quickFetch, see docs for details.</span>
<span class="sd">    filt : list</span>
<span class="sd">        A list of the required input parameters for the obspy bandpass </span>
<span class="sd">        filter [freqmin, freqmax, corners, zerophase].</span>
<span class="sd">    stationKey : str or pd.DataFrame</span>
<span class="sd">        Path to the station key or DataFrame of station key.</span>
<span class="sd">    templateKey : str or pd.DataFrame</span>
<span class="sd">        Path to the template key or loaded template key in DataFrame.</span>
<span class="sd">    trim : list </span>
<span class="sd">        A list with seconds to trim from events with respect to the origin </span>
<span class="sd">        time reported in the template key (or optionally a first arivial time,</span>
<span class="sd">        see phases param for details). The default value of [10, 120] </span>
<span class="sd">        means each event will be trimmed to only contain 10 seconds before </span>
<span class="sd">        its origin time and 120 seconds after. The larger the values of this </span>
<span class="sd">        argument the longer the computation time and chance of misalignment,</span>
<span class="sd">        but values that are too small may trim out desired phases of the</span>
<span class="sd">        waveform. </span>
<span class="sd">    saveClust : bool</span>
<span class="sd">        If true save the cluster object in the current working </span>
<span class="sd">        directory. The name is controlled by the fileName parameter. </span>
<span class="sd">    fileName : str</span>
<span class="sd">        Path (or name) to save the clustering instance, only used </span>
<span class="sd">        if saveClust is True.</span>
<span class="sd">    decimate : int or None</span>
<span class="sd">        A decimation factor to apply to all data in order to decrease run </span>
<span class="sd">        time. Can be very useful if the the data are oversampled. For </span>
<span class="sd">        example, if the data are sampled at 200 Hz but a 1 to 10 Hz </span>
<span class="sd">        bandpass filter is applied it may be appropriate to apply a </span>
<span class="sd">        decimation factor of 5 to bring the sampling rate down to 40 hz. </span>
<span class="sd">    dytpe : str</span>
<span class="sd">        An option to recast data type of the seismic data. Options are:</span>
<span class="sd">            double- numpy float 64</span>
<span class="sd">            single- numpy float 32, much faster and amenable to cuda GPU </span>
<span class="sd">            processing, sacrifices precision.</span>
<span class="sd">    eventsOnAllStations : bool</span>
<span class="sd">        If True only use the events that occur on all stations, if </span>
<span class="sd">        false let each station have an independent event list.</span>
<span class="sd">    enforceOrigin : bool</span>
<span class="sd">        If True make sure each trace starts at the reported origin time in </span>
<span class="sd">        the template key. If not trim or merge with zeros. Required  for </span>
<span class="sd">        lag times to be meaningful for hypoDD input.</span>
<span class="sd">    fillZeros : bool</span>
<span class="sd">        If True fill zeros from trim[0] to trim[1]. Suggested for older </span>
<span class="sd">        data or if only triggered data are available.</span>
<span class="sd">    phases : None, str, or instance of DataFrame</span>
<span class="sd">        If not None a path to phase picks or a DataFrame of phase picks that</span>
<span class="sd">        will be used for trim values rather than referencing the origin time</span>
<span class="sd">        of each event. See issue 25 on detex github page for why this</span>
<span class="sd">        might be useful. </span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">        An instance of the detex SSClustering class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read in stationkey and template keys and check a few key parameters</span>
    <span class="n">stakey</span> <span class="o">=</span> <span class="n">detex</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">readKey</span><span class="p">(</span><span class="n">stationKey</span><span class="p">,</span> <span class="n">key_type</span><span class="o">=</span><span class="s1">&#39;station&#39;</span><span class="p">)</span>
    <span class="n">temkey</span> <span class="o">=</span> <span class="n">detex</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">readKey</span><span class="p">(</span><span class="n">templateKey</span><span class="p">,</span> <span class="n">key_type</span><span class="o">=</span><span class="s1">&#39;template&#39;</span><span class="p">)</span>
    <span class="n">_checkClusterInputs</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">trim</span><span class="p">,</span> <span class="n">decimate</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">phases</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">phases</span> <span class="o">=</span> <span class="n">detex</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">readKey</span><span class="p">(</span><span class="n">phases</span><span class="p">,</span> <span class="s2">&quot;phases&quot;</span><span class="p">)</span>

    <span class="c1"># get a data fetcher</span>
    <span class="n">fetcher</span> <span class="o">=</span> <span class="n">detex</span><span class="o">.</span><span class="n">getdata</span><span class="o">.</span><span class="n">quickFetch</span><span class="p">(</span><span class="n">fetch_arg</span><span class="p">,</span> <span class="n">fillZeros</span><span class="o">=</span><span class="n">fillZeros</span><span class="p">)</span>

    <span class="c1"># Intialize object DF that will be used to store cluster info</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Starting IO operations and data checks&#39;</span>
    <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">TRDF</span> <span class="o">=</span> <span class="n">_loadEvents</span><span class="p">(</span><span class="n">fetcher</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="p">,</span> <span class="n">stakey</span><span class="p">,</span> <span class="n">temkey</span><span class="p">,</span> <span class="n">decimate</span><span class="p">,</span>
                       <span class="n">dtype</span><span class="p">,</span> <span class="n">enforceOrigin</span><span class="o">=</span><span class="n">enforceOrigin</span><span class="p">,</span> <span class="n">phases</span><span class="o">=</span><span class="n">phases</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">TRDF</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if no events survive</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;No events survived pre-processing, check DataFetcher and event</span><span class="se">\</span>
<span class="s1">                quality&#39;</span><span class="p">)</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>

    <span class="c1"># Prune event that do not occur on all stations if required</span>
    <span class="k">if</span> <span class="n">eventsOnAllStations</span><span class="p">:</span>
        <span class="c1"># get list of events that occur on all required stations</span>
        <span class="n">eventList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">Events</span><span class="p">]))</span>
        <span class="n">eventList</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eventList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;less than 2 events in population have required stations&#39;</span>
            <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>

    <span class="c1"># Test number of events in each station</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">TRDF</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;No events survived preprocessing, examin input args and data&#39;</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Loop through entries for each station, perform clustering</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;performing cluster analysis on &#39;</span> <span class="o">+</span> <span class="n">row</span><span class="o">.</span><span class="n">Station</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">eventsOnAllStations</span><span class="p">:</span>
            <span class="n">eventList</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">Events</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">Events</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># if only one event on this station skip it</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Less than 2 valid events on station &#39;</span> <span class="o">+</span> <span class="n">row</span><span class="o">.</span><span class="n">Station</span>
            <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warning&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">DFcc</span><span class="p">,</span> <span class="n">DFlag</span><span class="p">,</span> <span class="n">DFsubsamp</span> <span class="o">=</span> <span class="n">_makeDFcclags</span><span class="p">(</span><span class="n">eventList</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">Lags</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFlag</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">CCs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFcc</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">Subsamp</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFsubsamp</span>
        <span class="n">cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">cxdf</span> <span class="o">=</span> <span class="mf">1.0000001</span> <span class="o">-</span> <span class="n">DFcc</span>  <span class="c1"># get dissimilarities</span>
        <span class="c1"># flatten ccs and remove nans</span>
        <span class="n">cx</span> <span class="o">=</span> <span class="n">_flatNoNan</span><span class="p">(</span><span class="n">cxdf</span><span class="p">)</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span>  <span class="c1"># get cluster linkage</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;Link&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
    <span class="c1"># define columns to keep</span>
    <span class="n">colstk</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Station&#39;</span><span class="p">,</span> <span class="s1">&#39;Link&#39;</span><span class="p">,</span> <span class="s1">&#39;CCs&#39;</span><span class="p">,</span> <span class="s1">&#39;Lags&#39;</span><span class="p">,</span> <span class="s1">&#39;Subsamp&#39;</span><span class="p">,</span> <span class="s1">&#39;Events&#39;</span><span class="p">,</span> <span class="s1">&#39;Stats&#39;</span><span class="p">]</span>
    <span class="n">trdf</span> <span class="o">=</span> <span class="n">TRDF</span><span class="p">[</span><span class="n">colstk</span><span class="p">]</span>
    <span class="n">eventListAll</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">Events</span><span class="p">]))</span>
    <span class="n">eventListAll</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="c1"># try:</span>
    <span class="n">clust</span> <span class="o">=</span> <span class="n">detex</span><span class="o">.</span><span class="n">subspace</span><span class="o">.</span><span class="n">ClusterStream</span><span class="p">(</span><span class="n">trdf</span><span class="p">,</span> <span class="n">temkey</span><span class="p">,</span> <span class="n">stakey</span><span class="p">,</span> <span class="n">fetcher</span><span class="p">,</span>
                                         <span class="n">eventListAll</span><span class="p">,</span> <span class="n">CCreq</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">decimate</span><span class="p">,</span>
                                         <span class="n">trim</span><span class="p">,</span> <span class="n">fileName</span><span class="p">,</span> <span class="n">eventsOnAllStations</span><span class="p">,</span>
                                         <span class="n">enforceOrigin</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">saveclust</span><span class="p">:</span>
        <span class="n">clust</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">clust</span></div>


<span class="c1">######################### SUBSPACE FUNCTIONS AND CLASSES #####################</span>


<div class="viewcode-block" id="createSubSpace"><a class="viewcode-back" href="../../detex.html#detex.construct.createSubSpace">[docs]</a><span class="k">def</span> <span class="nf">createSubSpace</span><span class="p">(</span><span class="n">Pf</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="n">clust</span><span class="o">=</span><span class="s1">&#39;clust.pkl&#39;</span><span class="p">,</span> <span class="n">minEvents</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;double&#39;</span><span class="p">,</span>
                   <span class="n">conDatFetcher</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to create subspaces on all available stations based on the </span>
<span class="sd">    clusters in Clustering object which will either be passed directly as the </span>
<span class="sd">    keyword clust or will be loaded from the path in clustFile</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    Pf : float</span>
<span class="sd">        The probability of false detection as modeled by the statistical </span>
<span class="sd">        framework in Harris 2006 Theory (eq 20, not yet supported)</span>
<span class="sd">        Or by fitting a PDF to an empirical estimation of the null space </span>
<span class="sd">        (similar to Wiechecki-Vergara 2001). Thresholds are not set until </span>
<span class="sd">        calling the SVD function of the subspace stream class.</span>
<span class="sd">    clust: str or instance of detex.subspace.ClusterStream</span>
<span class="sd">        The path to a pickled instance of ClusterStream or an instance of </span>
<span class="sd">        ClusterStream. Used in defining the subspaces.</span>
<span class="sd">    minEvents : int</span>
<span class="sd">        The Min number of events that must be in a cluster in order for a </span>
<span class="sd">        subspace to be created from that cluster.</span>
<span class="sd">    dtype : str (&#39;single&#39; or &#39;double&#39;)</span>
<span class="sd">        The data type of the numpy arrays used in the detections. Options are:</span>
<span class="sd">            single- a np.float32, slightly faster (~30%) less precise </span>
<span class="sd">            double- a np.float64 (default)</span>
<span class="sd">    conDatFetcher : None, str, or instance of detex.getdata.DataFetcher</span>
<span class="sd">        Parameter to indicate how continuous data will be fetched in the newly</span>
<span class="sd">        created instance of SubSpace. Descriptions are the three accepted types</span>
<span class="sd">        are:</span>
<span class="sd">        1. (None) If None is passed detex will try to deduce the appropriate</span>
<span class="sd">        type of DataFetcher from the event datafetcher attached to cluster</span>
<span class="sd">        instance.</span>
<span class="sd">        2. (str) conDatFetcher is a string it will be passed to </span>
<span class="sd">        detex.getdata.quickFetch function which expects a path to the </span>
<span class="sd">        directory where the data are stored or a valid DataFetcher method.</span>
<span class="sd">        See the docs of the quickFetch function in detex.getdata for more info.</span>
<span class="sd">        3. (instance of detex.getdata.DataFetcher) If an instance of </span>
<span class="sd">        detex.getdata.DataFetcher is passed then it will be used as the</span>
<span class="sd">        continuous data fetcher.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -----------</span>
<span class="sd">    An instance of the SubSpace class</span>
<span class="sd">    </span>
<span class="sd">        Note</span>
<span class="sd">    ----------</span>
<span class="sd">    Most of the parameters that define how to fetch seismic data, which events</span>
<span class="sd">    and stations to use in the analysis, filter parameters, etc. are already </span>
<span class="sd">    defined in the cluster (ClusterStream) instance.     </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Read in cluster instance</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clust</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>  <span class="c1"># if no cluster object passed read a pickled one</span>
        <span class="n">cl</span> <span class="o">=</span> <span class="n">detex</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">loadClusters</span><span class="p">(</span><span class="n">clust</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clust</span><span class="p">,</span> <span class="n">detex</span><span class="o">.</span><span class="n">subspace</span><span class="o">.</span><span class="n">ClusterStream</span><span class="p">):</span>
        <span class="n">cl</span> <span class="o">=</span> <span class="n">clust</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Invalid clust type, must be a path or ClusterStream instance.&#39;</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="ne">ValueError</span><span class="p">)</span>
    <span class="c1"># Get info from cluster, load fetchers</span>
    <span class="n">temkey</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">temkey</span>
    <span class="n">stakey</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">stakey</span>
    <span class="n">efetcher</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">fetcher</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conDatFetcher</span><span class="p">,</span> <span class="n">detex</span><span class="o">.</span><span class="n">getdata</span><span class="o">.</span><span class="n">DataFetcher</span><span class="p">):</span>
        <span class="n">cfetcher</span> <span class="o">=</span> <span class="n">conDatFetcher</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conDatFetcher</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">cfetcher</span> <span class="o">=</span> <span class="n">detex</span><span class="o">.</span><span class="n">getdata</span><span class="o">.</span><span class="n">quickFetch</span><span class="p">(</span><span class="n">conDatFetcher</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">conDatFetcher</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">efetcher</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;dir&#39;</span><span class="p">:</span>
            <span class="n">cfetcher</span> <span class="o">=</span> <span class="n">detex</span><span class="o">.</span><span class="n">getdata</span><span class="o">.</span><span class="n">quickFetch</span><span class="p">(</span><span class="s1">&#39;ContinuousWaveForms&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if not directory assume obspy client used for both</span>
            <span class="n">cfetcher</span> <span class="o">=</span> <span class="n">efetcher</span>

    <span class="c1"># Load events into main dataframe to create subspaces</span>
    <span class="n">TRDF</span> <span class="o">=</span> <span class="n">_loadEvents</span><span class="p">(</span><span class="n">efetcher</span><span class="p">,</span> <span class="n">cl</span><span class="o">.</span><span class="n">filt</span><span class="p">,</span> <span class="n">cl</span><span class="o">.</span><span class="n">trim</span><span class="p">,</span> <span class="n">stakey</span><span class="p">,</span> <span class="n">temkey</span><span class="p">,</span> <span class="n">cl</span><span class="o">.</span><span class="n">decimate</span><span class="p">,</span>
                       <span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>  <span class="c1"># Fill in cluster info from cluster object</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;Link&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cl</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Station</span><span class="p">]</span><span class="o">.</span><span class="n">link</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;Clust&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cl</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Station</span><span class="p">]</span><span class="o">.</span><span class="n">clusts</span>

        <span class="c1"># Start subspace construction</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Starting Subspace Construction&#39;</span>
    <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ssDict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dict to store subspaces in</span>
    <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>  <span class="c1"># Loop through each station</span>
        <span class="n">staSS</span> <span class="o">=</span> <span class="n">_makeSSDF</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">minEvents</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">staSS</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if no clusters form on current station</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;No events grouped into subspaces on </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">row</span><span class="o">.</span><span class="n">Station</span>
            <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warning&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">sind</span><span class="p">,</span> <span class="n">srow</span> <span class="ow">in</span> <span class="n">staSS</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>  <span class="c1"># loop each cluster</span>
            <span class="n">eventList</span> <span class="o">=</span> <span class="n">srow</span><span class="o">.</span><span class="n">Events</span>

            <span class="c1"># get correlation values from cl object</span>
            <span class="n">DFcc</span><span class="p">,</span> <span class="n">DFlag</span> <span class="o">=</span> <span class="n">_getInfoFromClust</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">srow</span><span class="p">)</span>
            <span class="n">staSS</span><span class="p">[</span><span class="s1">&#39;Lags&#39;</span><span class="p">][</span><span class="n">sind</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFlag</span>
            <span class="n">staSS</span><span class="p">[</span><span class="s1">&#39;CCs&#39;</span><span class="p">][</span><span class="n">sind</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFcc</span>
            <span class="n">cxdf</span> <span class="o">=</span> <span class="mf">1.0000001</span> <span class="o">-</span> <span class="n">DFcc</span>
            <span class="n">cx</span> <span class="o">=</span> <span class="n">_flatNoNan</span><span class="p">(</span><span class="n">cxdf</span><span class="p">)</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cxdf</span> <span class="o">=</span> <span class="n">_ensureUnique</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cxdf</span><span class="p">)</span>  <span class="c1"># ensure cc value is unique</span>
            <span class="n">lags</span> <span class="o">=</span> <span class="n">_flatNoNan</span><span class="p">(</span><span class="n">DFlag</span><span class="p">)</span>
            <span class="n">link</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span>  <span class="c1"># get cluster linkage</span>
            <span class="n">staSS</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sind</span><span class="p">,</span> <span class="s1">&#39;Link&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
            <span class="c1"># get lag times and align waveforms</span>
            <span class="n">CCtoLag</span> <span class="o">=</span> <span class="n">_makeCC2LagMap</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">lags</span><span class="p">)</span>  <span class="c1"># a map from cc to lag times</span>
            <span class="n">delays</span><span class="p">,</span> <span class="n">dflink</span> <span class="o">=</span> <span class="n">_getDelays</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">CCtoLag</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">cxdf</span><span class="p">)</span>
            <span class="n">delayNP</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">delays</span><span class="p">)</span>
            <span class="n">delayDF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">delays</span> <span class="o">+</span> <span class="n">delayNP</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;SampleDelays&#39;</span><span class="p">])</span>
            <span class="n">delayDF</span><span class="p">[</span><span class="s1">&#39;Events&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">eventList</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">delayDF</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="n">staSS</span><span class="p">[</span><span class="s1">&#39;AlignedTD&#39;</span><span class="p">][</span><span class="n">sind</span><span class="p">]</span> <span class="o">=</span> <span class="n">_alignTD</span><span class="p">(</span><span class="n">delayDF</span><span class="p">,</span> <span class="n">srow</span><span class="p">)</span>
            <span class="n">ustimes</span> <span class="o">=</span> <span class="n">_updateStartTimes</span><span class="p">(</span><span class="n">srow</span><span class="p">,</span> <span class="n">delayDF</span><span class="p">,</span> <span class="n">temkey</span><span class="p">)</span>
            <span class="n">staSS</span><span class="p">[</span><span class="s1">&#39;Stats&#39;</span><span class="p">][</span><span class="n">sind</span><span class="p">]</span> <span class="o">=</span> <span class="n">ustimes</span>  <span class="c1"># update Start Times</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">_getOffsetList</span><span class="p">(</span><span class="n">sind</span><span class="p">,</span> <span class="n">srow</span><span class="p">,</span> <span class="n">staSS</span><span class="p">)</span>
            <span class="n">offsetAr</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">offsets</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">offsets</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">offsets</span><span class="p">)]</span>
            <span class="n">staSS</span><span class="p">[</span><span class="s1">&#39;Offsets&#39;</span><span class="p">][</span><span class="n">sind</span><span class="p">]</span> <span class="o">=</span> <span class="n">offsetAr</span>
        <span class="c1"># Put output into subspaceDict</span>
        <span class="n">staOut</span> <span class="o">=</span> <span class="n">staSS</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;MPfd&#39;</span><span class="p">,</span> <span class="s1">&#39;MPtd&#39;</span><span class="p">,</span> <span class="s1">&#39;Link&#39;</span><span class="p">,</span> <span class="s1">&#39;Lags&#39;</span><span class="p">,</span> <span class="s1">&#39;CCs&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ssDict</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Station</span><span class="p">]</span> <span class="o">=</span> <span class="n">staOut</span>
    <span class="c1"># make a list of sngles to pass to subspace class</span>
    <span class="n">singDic</span> <span class="o">=</span> <span class="n">_makeSingleEventDict</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">TRDF</span><span class="p">,</span> <span class="n">temkey</span><span class="p">)</span>

    <span class="n">substream</span> <span class="o">=</span> <span class="n">detex</span><span class="o">.</span><span class="n">subspace</span><span class="o">.</span><span class="n">SubSpace</span><span class="p">(</span><span class="n">singDic</span><span class="p">,</span> <span class="n">ssDict</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">Pf</span><span class="p">,</span>
                                        <span class="n">cfetcher</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Finished CreateSubSpace call&quot;</span>
    <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">substream</span></div>


<span class="k">def</span> <span class="nf">_getInfoFromClust</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">srow</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    get the DFcc dataframe and lags dataframe from values already stored in</span>
<span class="sd">    cluster object to avoid recalculating them</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sta</span> <span class="o">=</span> <span class="n">srow</span><span class="o">.</span><span class="n">Station</span>
    <span class="n">cll</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">trdf</span><span class="p">[</span><span class="n">cl</span><span class="o">.</span><span class="n">trdf</span><span class="o">.</span><span class="n">Station</span> <span class="o">==</span> <span class="n">sta</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">odi</span> <span class="o">=</span> <span class="n">_makeEventListKey</span><span class="p">(</span><span class="n">srow</span><span class="o">.</span><span class="n">Events</span><span class="p">,</span> <span class="n">cll</span><span class="o">.</span><span class="n">Events</span><span class="p">)</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">odi</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">odi</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">DFlag</span> <span class="o">=</span> <span class="n">cll</span><span class="o">.</span><span class="n">Lags</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inds</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span>
    <span class="n">DFlag</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DFlag</span><span class="p">))</span>
    <span class="n">DFlag</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">DFlag</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">DFcc</span> <span class="o">=</span> <span class="n">cll</span><span class="o">.</span><span class="n">CCs</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inds</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span>
    <span class="n">DFcc</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DFlag</span><span class="p">))</span>
    <span class="n">DFcc</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">DFlag</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DFcc</span><span class="p">,</span> <span class="n">DFlag</span>


<span class="k">def</span> <span class="nf">_makeEventListKey</span><span class="p">(</span><span class="n">evelist1</span><span class="p">,</span> <span class="n">evelist2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make index key to make evelist1 to evelist2 </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">odi</span> <span class="o">=</span> <span class="p">[</span><span class="n">_fastWhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">evelist2</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">evelist1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">odi</span>


<span class="k">def</span> <span class="nf">_fastWhere</span><span class="p">(</span><span class="n">eve</span><span class="p">,</span> <span class="n">objs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    like np.where but a bit faster because data checks are skipped</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">an</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">nu</span> <span class="k">for</span> <span class="n">nu</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span> <span class="k">if</span> <span class="n">eve</span> <span class="o">==</span> <span class="n">obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">an</span>


<span class="k">def</span> <span class="nf">_getOffsetList</span><span class="p">(</span><span class="n">sind</span><span class="p">,</span> <span class="n">srow</span><span class="p">,</span> <span class="n">staSS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    get list of offsets and return it</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">staSS</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sind</span><span class="p">,</span> <span class="s1">&#39;Stats&#39;</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">srow</span><span class="o">.</span><span class="n">Stats</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>


<span class="k">def</span> <span class="nf">_updateStartTimes</span><span class="p">(</span><span class="n">srow</span><span class="p">,</span> <span class="n">delayDF</span><span class="p">,</span> <span class="n">temkey</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Update the starttimes to reflect the values trimed in alignement</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">statsdict</span> <span class="o">=</span> <span class="n">srow</span><span class="o">.</span><span class="n">Stats</span>
    <span class="n">sdo</span> <span class="o">=</span> <span class="n">srow</span><span class="o">.</span><span class="n">Stats</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sdo</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">temtemkey</span> <span class="o">=</span> <span class="n">temkey</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">temkey</span><span class="o">.</span><span class="n">NAME</span> <span class="o">==</span> <span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">delaysamps</span> <span class="o">=</span> <span class="n">delayDF</span><span class="p">[</span><span class="n">delayDF</span><span class="o">.</span><span class="n">Events</span> <span class="o">==</span> <span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">SampleDelays</span>
        <span class="n">Nc</span> <span class="o">=</span> <span class="n">sdo</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;Nc&#39;</span><span class="p">]</span>
        <span class="n">sr</span> <span class="o">=</span> <span class="n">sdo</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;sampling_rate&#39;</span><span class="p">]</span>
        <span class="n">stime</span> <span class="o">=</span> <span class="n">sdo</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starttime&#39;</span><span class="p">]</span>

        <span class="n">stime_new</span> <span class="o">=</span> <span class="n">stime</span> <span class="o">+</span> <span class="n">delaysamps</span> <span class="o">/</span> <span class="p">(</span><span class="n">sr</span> <span class="o">*</span> <span class="n">Nc</span><span class="p">)</span>  <span class="c1"># updated starttime to trim</span>
        <span class="n">statsdict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starttime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stime_new</span>
        <span class="n">otime</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">temtemkey</span><span class="o">.</span><span class="n">TIME</span><span class="p">)</span><span class="o">.</span><span class="n">timestamp</span>  <span class="c1"># starttime</span>
        <span class="n">statsdict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;starttime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stime</span> <span class="o">+</span> <span class="n">delaysamps</span> <span class="o">/</span> <span class="p">(</span><span class="n">sr</span> <span class="o">*</span> <span class="n">Nc</span><span class="p">)</span>
        <span class="n">statsdict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;origintime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">otime</span>
        <span class="n">statsdict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;magnitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temtemkey</span><span class="o">.</span><span class="n">MAG</span>
        <span class="n">statsdict</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stime_new</span> <span class="o">-</span> <span class="n">otime</span>  <span class="c1"># predict offset time</span>
    <span class="k">return</span> <span class="n">statsdict</span>


<span class="k">def</span> <span class="nf">_makeDFcclags</span><span class="p">(</span><span class="n">eventList</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to make correlation matrix and lag time matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">eventList</span><span class="p">))</span>
    <span class="n">indicies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">eventList</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">DFcc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">indicies</span><span class="p">)</span>
    <span class="n">DFlag</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">indicies</span><span class="p">)</span>
    <span class="n">DFsubsamp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">indicies</span><span class="p">)</span>

    <span class="c1"># Loop over indicies and fill in cc and lags</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">DFcc</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">DFcc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">rev</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># if order is switched multiply lags by -1</span>
            <span class="n">mptd1</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;MPtd&#39;</span><span class="p">][</span><span class="n">eventList</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
            <span class="n">mptd2</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;MPtd&#39;</span><span class="p">][</span><span class="n">eventList</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
            <span class="n">mpfd1</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;MPfd&#39;</span><span class="p">][</span><span class="n">eventList</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
            <span class="n">mpfd2</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;MPfd&#39;</span><span class="p">][</span><span class="n">eventList</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
            <span class="n">Nc1</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;Channels&#39;</span><span class="p">][</span><span class="n">eventList</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
            <span class="n">Nc2</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;Channels&#39;</span><span class="p">][</span><span class="n">eventList</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
            <span class="n">maxcc</span><span class="p">,</span> <span class="n">sampleLag</span><span class="p">,</span> <span class="n">subsamp</span> <span class="o">=</span> <span class="n">_CCX2</span><span class="p">(</span><span class="n">mpfd1</span><span class="p">,</span> <span class="n">mpfd2</span><span class="p">,</span> <span class="n">mptd1</span><span class="p">,</span> <span class="n">mptd2</span><span class="p">,</span> <span class="n">Nc1</span><span class="p">,</span>
                                              <span class="n">Nc2</span><span class="p">)</span>
            <span class="n">DFcc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxcc</span>
            <span class="n">DFlag</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampleLag</span>
            <span class="n">DFsubsamp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">subsamp</span>
    <span class="k">return</span> <span class="n">DFcc</span><span class="p">,</span> <span class="n">DFlag</span> <span class="o">*</span> <span class="n">rev</span><span class="p">,</span> <span class="n">DFsubsamp</span>


<span class="k">def</span> <span class="nf">_subSamp</span><span class="p">(</span><span class="n">Ceval</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Method to estimate subsample time delays using cosine-fit interpolation</span>
<span class="sd">    Cespedes, I., Huang, Y., Ophir, J. &amp; Spratt, S. </span>
<span class="sd">    Methods for estimation of sub-sample time delays of digitized echo signals. </span>
<span class="sd">    Ultrason. Imaging 17, 142171 (1995)</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The amount the sample should be shifted (float between -.5 and .5)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If max occurs at start or end of CC no extrapolation</span>
    <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ind</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ceval</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cb4</span> <span class="o">=</span> <span class="n">Ceval</span><span class="p">[</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">caf</span> <span class="o">=</span> <span class="n">Ceval</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="n">Ceval</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">((</span><span class="n">cb4</span> <span class="o">+</span> <span class="n">caf</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cn</span><span class="p">))</span>
        <span class="n">alsi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="n">cb4</span> <span class="o">-</span> <span class="n">caf</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">cn</span> <span class="o">*</span> <span class="n">alsi</span><span class="p">))</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">.</span><span class="mi">5</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;subsample failing, more than .5 sample shift predicted&#39;</span><span class="p">)</span>
            <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;Warning&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ind</span>
    <span class="k">return</span> <span class="n">tau</span>


<span class="k">def</span> <span class="nf">_CCX2</span><span class="p">(</span><span class="n">mpfd1</span><span class="p">,</span> <span class="n">mpfd2</span><span class="p">,</span> <span class="n">mptd1</span><span class="p">,</span> <span class="n">mptd2</span><span class="p">,</span> <span class="n">Nc1</span><span class="p">,</span> <span class="n">Nc2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function find max correlation coeficient and corresponding lag time</span>
<span class="sd">    between 2 traces. fft should already have been calculated</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nc1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nc2</span><span class="p">):</span>  <span class="c1"># make sure there are the same number of channels</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Number of Channels not equal, cannot perform correlation&#39;</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>
    <span class="n">Nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Nc1</span><span class="p">)</span>  <span class="c1"># Number of channels</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mptd1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mptd2</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">mpfd2</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mpfd1</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Lengths not equal on multiplexed data, cannot correlate&#39;</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mptd1</span><span class="p">)</span>

    <span class="n">trunc</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Nc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># truncate value</span>
    <span class="c1"># trunc = n - 1</span>
    <span class="c1"># n = trunc + 1</span>

    <span class="n">mptd2Temp</span> <span class="o">=</span> <span class="n">mptd2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">mptd2Temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">mptd2Temp</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="s1">&#39;constant&#39;</span><span class="p">),</span>
                           <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">rolling_mean</span><span class="p">(</span><span class="n">mptd2Temp</span><span class="p">,</span> <span class="n">n</span><span class="p">)[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">rolling_std</span><span class="p">(</span><span class="n">mptd2Temp</span><span class="p">,</span> <span class="n">n</span><span class="p">)[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">b</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">fftpack</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">mpfd1</span><span class="p">),</span> <span class="n">mpfd2</span><span class="p">)))</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):],</span> <span class="n">c</span><span class="p">[:</span><span class="n">n</span><span class="p">]])</span>  <span class="c1"># swap end to start</span>
    <span class="c1"># slice by # of channels as not to mix match chans in multplexed stream</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="n">c1</span> <span class="o">-</span> <span class="n">mptd1</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">mptd1</span><span class="p">)))[</span><span class="n">Nc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">::</span><span class="n">Nc</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">trunc</span><span class="p">:</span> <span class="o">-</span><span class="n">trunc</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">maxcc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">mincc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">maxind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxcc</span> <span class="o">&gt;</span> <span class="mf">1.</span> <span class="ow">or</span> <span class="n">mincc</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.</span><span class="p">:</span>  <span class="c1"># if a inf is found in array</span>
            <span class="c1"># this can happen if some of the waveforms have been zeroed out</span>
            <span class="n">result</span><span class="p">[(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">maxcc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">maxind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># if fails skip</span>
        <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
    <span class="n">subsamp</span> <span class="o">=</span> <span class="n">_subSamp</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">maxind</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">maxcc</span><span class="p">,</span> <span class="p">(</span><span class="n">maxind</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">trunc</span><span class="p">)</span> <span class="o">*</span> <span class="n">Nc</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">subsamp</span>


<div class="viewcode-block" id="fast_normcorr"><a class="viewcode-back" href="../../detex.html#detex.construct.fast_normcorr">[docs]</a><span class="k">def</span> <span class="nf">fast_normcorr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fast normalized cc</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>  <span class="c1"># switch t and s if t is larger than s</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">sum_nt</span> <span class="o">=</span> <span class="n">nt</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">rolling_mean</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">rolling_std</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">b</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">nt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;valid&quot;</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">sum_nt</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="k">def</span> <span class="nf">_alignTD</span><span class="p">(</span><span class="n">delayDF</span><span class="p">,</span> <span class="n">srow</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    loop through delay Df and apply offsets to create alligned </span>
<span class="sd">    arrays dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">aligned</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># find the required length for each aligned stream</span>
    <span class="n">TDlengths</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">srow</span><span class="o">.</span><span class="n">MPtd</span><span class="p">[</span><span class="n">delayDF</span><span class="o">.</span><span class="n">Events</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">delayDF</span><span class="o">.</span><span class="n">SampleDelays</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">delayDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="n">srow</span><span class="o">.</span><span class="n">MPtd</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Events</span><span class="p">]</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="n">orig</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">SampleDelays</span><span class="p">:]</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="n">orig</span><span class="p">[:</span><span class="n">TDlengths</span><span class="p">]</span>
        <span class="n">aligned</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Events</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Alignment of multiplexed stream failing on </span><span class="si">%s</span><span class="s1">, </span><span class="se">\</span>
<span class="s1">                   try raising ccreq or widenning trim window&#39;</span> <span class="o">%</span> <span class="n">srow</span><span class="o">.</span><span class="n">Station</span><span class="p">)</span>
            <span class="n">msg2</span> <span class="o">=</span> <span class="n">_idAlignProblems</span><span class="p">(</span><span class="n">delayDF</span><span class="p">)</span>
            <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span> <span class="o">+</span> <span class="n">msg2</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">aligned</span>


<span class="k">def</span> <span class="nf">_idAlignProblems</span><span class="p">(</span><span class="n">delayDF</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function that is called when alignment fails, trys to ID which events</span>
<span class="sd">    are causing problems and append this info to the message that is sent to</span>
<span class="sd">    the logger</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="n">delayDF</span><span class="o">.</span><span class="n">SampleDelays</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">offsets</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">offsets</span><span class="p">))</span>
    <span class="n">mdev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">mdev</span> <span class="k">if</span> <span class="n">mdev</span> <span class="k">else</span> <span class="mf">0.</span>
    <span class="n">offs</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">]</span>  <span class="c1"># events that are potentially causing problems</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">off</span> <span class="ow">in</span> <span class="n">offs</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="p">((</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Alignment shift for event </span><span class="si">%s</span><span class="s1"> is an outlier &#39;</span>
                 <span class="s1">&#39;consider removing it&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">delayDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">Events</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">msg</span>


<span class="k">def</span> <span class="nf">_makeSingleEventDict</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">TRDF</span><span class="p">,</span> <span class="n">temkey</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make dict of dataframes for singles on each station</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">singlesdict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Clust&#39;</span><span class="p">,</span> <span class="s1">&#39;Link&#39;</span><span class="p">,</span> <span class="s1">&#39;Lags&#39;</span><span class="p">,</span> <span class="s1">&#39;CCs&#39;</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">singleslist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">cl</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Station</span><span class="p">]</span><span class="o">.</span><span class="n">singles</span><span class="p">)</span>  <span class="c1"># init list</span>
        <span class="n">DF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">singleslist</span><span class="p">)),</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">singleslist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if no singles on this channel</span>
            <span class="k">break</span>
        <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Offsets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span>
        <span class="k">for</span> <span class="n">sn</span><span class="p">,</span> <span class="n">sing</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">singleslist</span><span class="p">):</span>
            <span class="c1"># DF.Events[a[0]]=evlist\</span>
            <span class="n">evelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">cl</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Station</span><span class="p">]</span><span class="o">.</span><span class="n">singles</span><span class="p">[</span><span class="n">sn</span><span class="p">]]</span>
            <span class="n">temtemkey</span> <span class="o">=</span> <span class="n">temkey</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">temkey</span><span class="o">.</span><span class="n">NAME</span> <span class="o">==</span> <span class="n">evelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">DF</span><span class="p">[</span><span class="s2">&quot;Station&quot;</span><span class="p">][</span><span class="n">sn</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">Station</span>
            <span class="n">DF</span><span class="p">[</span><span class="s2">&quot;MPtd&quot;</span><span class="p">][</span><span class="n">sn</span><span class="p">]</span> <span class="o">=</span> <span class="n">_trimDict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="s1">&#39;MPtd&#39;</span><span class="p">,</span> <span class="n">evelist</span><span class="p">)</span>
            <span class="n">DF</span><span class="p">[</span><span class="s2">&quot;MPfd&quot;</span><span class="p">][</span><span class="n">sn</span><span class="p">]</span> <span class="o">=</span> <span class="n">_trimDict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="s1">&#39;MPfd&#39;</span><span class="p">,</span> <span class="n">evelist</span><span class="p">)</span>
            <span class="n">DF</span><span class="p">[</span><span class="s2">&quot;Stats&quot;</span><span class="p">][</span><span class="n">sn</span><span class="p">]</span> <span class="o">=</span> <span class="n">_trimDict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="s1">&#39;Stats&#39;</span><span class="p">,</span> <span class="n">evelist</span><span class="p">)</span>
            <span class="n">DF</span><span class="p">[</span><span class="s2">&quot;Channels&quot;</span><span class="p">][</span><span class="n">sn</span><span class="p">]</span> <span class="o">=</span> <span class="n">_trimDict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="s1">&#39;Channels&#39;</span><span class="p">,</span> <span class="n">evelist</span><span class="p">)</span>
            <span class="n">otime</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">temtemkey</span><span class="o">.</span><span class="n">TIME</span><span class="p">)</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="n">stime</span> <span class="o">=</span> <span class="n">DF</span><span class="o">.</span><span class="n">Stats</span><span class="p">[</span><span class="n">sn</span><span class="p">][</span><span class="n">evelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;starttime&#39;</span><span class="p">]</span>
            <span class="n">DF</span><span class="o">.</span><span class="n">Stats</span><span class="p">[</span><span class="n">sn</span><span class="p">][</span><span class="n">evelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;origintime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">otime</span>

            <span class="n">DF</span><span class="o">.</span><span class="n">Stats</span><span class="p">[</span><span class="n">sn</span><span class="p">][</span><span class="n">evelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stime</span> <span class="o">-</span> <span class="n">otime</span>
            <span class="n">DF</span><span class="o">.</span><span class="n">Stats</span><span class="p">[</span><span class="n">sn</span><span class="p">][</span><span class="n">evelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;magnitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temtemkey</span><span class="o">.</span><span class="n">MAG</span>
            <span class="n">DF</span><span class="o">.</span><span class="n">Events</span><span class="p">[</span><span class="n">sn</span><span class="p">]</span> <span class="o">=</span> <span class="n">DF</span><span class="o">.</span><span class="n">MPtd</span><span class="p">[</span><span class="n">sn</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">DF</span><span class="o">.</span><span class="n">Name</span><span class="p">[</span><span class="n">sn</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;SG</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sn</span>
        <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;SampleTrims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DF</span><span class="p">))]</span>
        <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;FAS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
        <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
        <span class="n">singlesdict</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">Station</span><span class="p">]</span> <span class="o">=</span> <span class="n">DF</span>
    <span class="k">return</span> <span class="n">singlesdict</span>


<span class="k">def</span> <span class="nf">_makeSSDF</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">minEvents</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to change form of TRDF for subpace creation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">Clust</span><span class="p">))</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">index</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;Clust&#39;</span><span class="p">]</span>
    <span class="n">DF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SS</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DF</span><span class="p">))]</span>  <span class="c1"># name subspaces</span>
    <span class="c1"># Initialize columns for future use</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Events&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;AlignedTD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;SVD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;UsedSVDKeys&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;FracEnergy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;SVDdefined&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;SampleTrims&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DF</span><span class="p">))]</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;SigDimRep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;FAS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;NumBasis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Offsets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Stats&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;MPtd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;MPfd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Channels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span>
    <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Station&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">Station</span>
    <span class="n">DF</span> <span class="o">=</span> <span class="n">DF</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">row2</span> <span class="ow">in</span> <span class="n">DF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">evelist</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">Clust</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">evelist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Events&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">evelist</span>
        <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;numEvents&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">evelist</span><span class="p">)</span>
        <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;MPtd&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">_trimDict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="s1">&#39;MPtd&#39;</span><span class="p">,</span> <span class="n">evelist</span><span class="p">)</span>
        <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;MPfd&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">_trimDict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="s1">&#39;MPfd&#39;</span><span class="p">,</span> <span class="n">evelist</span><span class="p">)</span>
        <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Stats&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">_trimDict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="s1">&#39;Stats&#39;</span><span class="p">,</span> <span class="n">evelist</span><span class="p">)</span>
        <span class="n">DF</span><span class="p">[</span><span class="s1">&#39;Channels&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">_trimDict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="s1">&#39;Channels&#39;</span><span class="p">,</span> <span class="n">evelist</span><span class="p">)</span>
    <span class="c1"># only keep subspaces that meet min req, dont renumber</span>
    <span class="n">DF</span> <span class="o">=</span> <span class="n">DF</span><span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">minEvents</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">DF</span><span class="o">.</span><span class="n">Events</span><span class="p">]]</span>
    <span class="c1"># DF.reset_index(drop=True, inplace=True)</span>
    <span class="k">return</span> <span class="n">DF</span>


<span class="k">def</span> <span class="nf">_trimDict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">evelist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function used to get only desired values form dictionary </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">temdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">evelist</span><span class="p">}</span>
    <span class="n">dictout</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">temdict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">dictout</span>


<span class="c1">############## Shared Subspace and Cluster Functions #####################</span>

<span class="k">def</span> <span class="nf">_loadEvents</span><span class="p">(</span><span class="n">fetcher</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="p">,</span> <span class="n">stakey</span><span class="p">,</span> <span class="n">temkey</span><span class="p">,</span> <span class="n">decimate</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span>
                <span class="n">enforceOrigin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">phases</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize TRDF, a container for a great many things including </span>
<span class="sd">    event templates, multiplexed data, obspy traces etc.   </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Events&#39;</span><span class="p">,</span> <span class="s1">&#39;MPtd&#39;</span><span class="p">,</span> <span class="s1">&#39;MPfd&#39;</span><span class="p">,</span> <span class="s1">&#39;Channels&#39;</span><span class="p">,</span> <span class="s1">&#39;Stats&#39;</span><span class="p">,</span> <span class="s1">&#39;Link&#39;</span><span class="p">,</span> <span class="s1">&#39;Clust&#39;</span><span class="p">,</span>
               <span class="s1">&#39;Lags&#39;</span><span class="p">,</span> <span class="s1">&#39;Subsamp&#39;</span><span class="p">,</span> <span class="s1">&#39;CCs&#39;</span><span class="p">,</span> <span class="s1">&#39;numEvents&#39;</span><span class="p">]</span>
    <span class="n">TRDF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
    <span class="n">stanets</span> <span class="o">=</span> <span class="n">stakey</span><span class="o">.</span><span class="n">NETWORK</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">stakey</span><span class="o">.</span><span class="n">STATION</span>
    <span class="n">TRDF</span><span class="p">[</span><span class="s1">&#39;Station&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stanets</span>
    <span class="n">TRDF</span><span class="p">[</span><span class="s1">&#39;Keep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">TRDF</span> <span class="o">=</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>  <span class="c1"># cast as objects so pandas can be abused ;)</span>

    <span class="c1"># Make list in data frame that shows which stations are in each event</span>
    <span class="c1"># Load streams into dataframe to call later</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">TRDF</span><span class="p">[</span><span class="s1">&#39;MPtd&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">TRDF</span><span class="p">[</span><span class="s1">&#39;MPfd&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sts</span><span class="p">,</span> <span class="n">eves</span><span class="p">,</span> <span class="n">chans</span><span class="p">,</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">_loadStream</span><span class="p">(</span><span class="n">fetcher</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="p">,</span> <span class="n">decimate</span><span class="p">,</span>
                                              <span class="n">row</span><span class="o">.</span><span class="n">Station</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">temkey</span><span class="p">,</span>
                                              <span class="n">stakey</span><span class="p">,</span> <span class="n">enforceOrigin</span><span class="p">,</span>
                                              <span class="n">phases</span><span class="o">=</span><span class="n">phases</span><span class="p">)</span>
        <span class="n">TRDF</span><span class="p">[</span><span class="s1">&#39;Events&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">eves</span>
        <span class="n">TRDF</span><span class="p">[</span><span class="s1">&#39;Channels&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">chans</span>
        <span class="n">TRDF</span><span class="p">[</span><span class="s1">&#39;Stats&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span>
        <span class="c1"># Make sure some events are good for given station</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">TRDF</span><span class="p">[</span><span class="s1">&#39;Events&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;Keep&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">continue</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;numEvents&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;Events&#39;</span><span class="p">])</span>

        <span class="c1"># get multiplexed time domain and freq. domain arrays</span>
        <span class="n">TRDF</span> <span class="o">=</span> <span class="n">_getTimeDomainWFs</span><span class="p">(</span><span class="n">TRDF</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">sts</span><span class="p">,</span> <span class="n">eves</span><span class="p">)</span>
        <span class="n">TRDF</span> <span class="o">=</span> <span class="n">_testStreamLengths</span><span class="p">(</span><span class="n">TRDF</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>
        <span class="n">TRDF</span> <span class="o">=</span> <span class="n">_getFreqDomain</span><span class="p">(</span><span class="n">TRDF</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>

    <span class="n">TRDF</span> <span class="o">=</span> <span class="n">TRDF</span><span class="p">[</span><span class="n">TRDF</span><span class="o">.</span><span class="n">Keep</span><span class="p">]</span>
    <span class="n">TRDF</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;Station&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">TRDF</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TRDF</span>


<span class="k">def</span> <span class="nf">_getTimeDomainWFs</span><span class="p">(</span><span class="n">TRDF</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">sts</span><span class="p">,</span> <span class="n">eves</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">eves</span><span class="p">:</span>  <span class="c1"># loop each event</span>
        <span class="n">Nc</span> <span class="o">=</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;Stats&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;Nc&#39;</span><span class="p">]</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">multiplex</span><span class="p">(</span><span class="n">sts</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">Nc</span><span class="p">)</span>  <span class="c1"># multiplexed time domain</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">sts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>  <span class="c1"># current stream</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;MPtd&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span>
        <span class="n">stu</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span>  <span class="c1"># updated starttime</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;Stats&#39;</span><span class="p">][</span><span class="s1">&#39;starttime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stu</span>
    <span class="k">return</span> <span class="n">TRDF</span>


<span class="k">def</span> <span class="nf">_getFreqDomain</span><span class="p">(</span><span class="n">TRDF</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">Events</span><span class="p">:</span>  <span class="c1"># loop each event</span>
        <span class="n">mp</span> <span class="o">=</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;MPtd&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
        <span class="n">reqlen</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>  <span class="c1"># required length</span>
        <span class="n">reqlenbits</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">reqlen</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>  <span class="c1"># required length fd</span>
        <span class="n">mpfd</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">fftpack</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">reqlenbits</span><span class="p">)</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;MPfd&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpfd</span>
    <span class="k">return</span> <span class="n">TRDF</span>


<span class="k">def</span> <span class="nf">_testStreamLengths</span><span class="p">(</span><span class="n">TRDF</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
    <span class="n">lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">MPtd</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
    <span class="c1"># trim to smallest length if within 90% of median, else kill key</span>
    <span class="n">le</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">lens</span><span class="p">[</span><span class="n">lens</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">*</span> <span class="o">.</span><span class="mi">9</span><span class="p">])</span>

    <span class="n">keysToKill</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">Events</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">MPtd</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">le</span><span class="p">]</span>
    <span class="c1"># trim events slightly too small if any</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">Events</span><span class="p">:</span>
        <span class="n">trimed</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">MPtd</span><span class="p">[</span><span class="n">key</span><span class="p">][:</span><span class="n">le</span><span class="p">]</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;MPtd&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">trimed</span>
    <span class="c1"># rest keys on TRDF</span>
    <span class="n">tmar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">TRDF</span><span class="o">.</span><span class="n">Events</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
    <span class="n">tk</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">keysToKill</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">TRDF</span><span class="o">.</span><span class="n">Events</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span>
    <span class="n">TRDF</span><span class="o">.</span><span class="n">Events</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmar</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tk</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keysToKill</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> on </span><span class="si">%s</span><span class="s1"> is out of length tolerance, removing&#39;</span> <span class="o">%</span>
               <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">Station</span><span class="p">))</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">TRDF</span><span class="o">.</span><span class="n">MPtd</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TRDF</span>


<span class="k">def</span> <span class="nf">_flatNoNan</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take a dataframe of pure numerics, flatten into 1d array and remove NaNs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NAN</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ar</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ar</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_getDelays</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">CCtoLag</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">cxdf</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>  <span class="c1"># Lumber of events</span>
    <span class="c1"># append cluster numbers to link array</span>
    <span class="n">linkup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">clustDict</span> <span class="o">=</span> <span class="n">_getClustDict</span><span class="p">(</span><span class="n">linkup</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">linkup</span><span class="p">))</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;i1&#39;</span><span class="p">,</span> <span class="s1">&#39;i2&#39;</span><span class="p">,</span> <span class="s1">&#39;cc&#39;</span><span class="p">,</span> <span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;clust&#39;</span><span class="p">]</span>
    <span class="n">dflink</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">linkup</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dflink</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dflink</span><span class="p">[</span><span class="s1">&#39;II&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span>
    <span class="n">dflink</span><span class="p">[</span><span class="s1">&#39;ev1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dflink</span><span class="p">[</span><span class="s1">&#39;ev2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dflink</span> <span class="o">=</span> <span class="n">dflink</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dflink</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">ii1</span> <span class="o">=</span> <span class="n">clustDict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">i1</span><span class="p">)]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">ii2</span> <span class="o">=</span> <span class="n">clustDict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">i2</span><span class="p">)]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">dflink</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;II&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii1</span> <span class="o">+</span> <span class="n">ii2</span>
        <span class="c1"># get a dataframe with only index as ev1 and column as ev2</span>
        <span class="n">tempdf</span> <span class="o">=</span> <span class="n">cxdf</span><span class="p">[</span><span class="n">cxdf</span> <span class="o">==</span> <span class="n">row</span><span class="o">.</span><span class="n">cc</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dflink</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;ev1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempdf</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dflink</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="s1">&#39;ev2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempdf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">lags</span> <span class="o">=</span> <span class="n">_traceEventDendro</span><span class="p">(</span><span class="n">dflink</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">CCtoLag</span><span class="p">,</span> <span class="n">clustDict</span><span class="p">,</span>
                             <span class="n">clustDict</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">lags</span><span class="p">,</span> <span class="n">dflink</span>
    <span class="c1"># return clusts,lagByClust</span>


<span class="k">def</span> <span class="nf">_traceEventDendro</span><span class="p">(</span><span class="n">dflink</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">CCtoLag</span><span class="p">,</span> <span class="n">clustDict</span><span class="p">,</span> <span class="n">clus</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to follow ind1 through clustering linkage in linkup </span>
<span class="sd">    and return total offset time (used for alignment)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dflink</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if event is singleton return zero offset time</span>
        <span class="n">lagSeries</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">clus</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">allevents</span> <span class="o">=</span> <span class="n">dflink</span><span class="p">[</span><span class="s1">&#39;II&#39;</span><span class="p">][</span><span class="n">dflink</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
        <span class="n">allevents</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1"># total lags for each station</span>
        <span class="n">lagSeries</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dflink</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">allevents</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dflink</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ev1</span> <span class="ow">in</span> <span class="n">clustDict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">i1</span><span class="p">)]:</span>
                <span class="n">cl22</span> <span class="o">=</span> <span class="n">clustDict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">i2</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cl22</span> <span class="o">=</span> <span class="n">clustDict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">i1</span><span class="p">)]</span>
            <span class="c1"># reference cc to lag samps map, round and cast to sample int</span>
            <span class="n">currentLag</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">CCtoLag</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cc</span><span class="p">]))</span>

            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">cl22</span><span class="p">:</span>  <span class="c1"># record and update lags for second cluster</span>
                <span class="n">lagSeries</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="n">currentLag</span>
                <span class="n">lags</span> <span class="o">=</span> <span class="n">_updateLags</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dflink</span><span class="p">),</span> <span class="n">currentLag</span><span class="p">)</span>
            <span class="n">CCtoLag</span> <span class="o">=</span> <span class="n">_makeCC2LagMap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lags</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lagSeries</span>


<span class="k">def</span> <span class="nf">_updateLags</span><span class="p">(</span><span class="n">evenum</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">currentLag</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to add current lag shifts to effected </span>
<span class="sd">    lag times (see Haris 2006 appendix B)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dow</span> <span class="o">=</span> <span class="n">_getDow</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">evenum</span><span class="p">)</span>  <span class="c1"># get the index to add to lags for columns</span>
    <span class="n">acr</span> <span class="o">=</span> <span class="n">_getAcr</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">evenum</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">acr</span><span class="p">:</span>
        <span class="n">lags</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="n">currentLag</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dow</span><span class="p">:</span>
        <span class="n">lags</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-=</span> <span class="n">currentLag</span>
    <span class="k">return</span> <span class="n">lags</span>


<span class="k">def</span> <span class="nf">_getDow</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">evenum</span><span class="p">):</span>
    <span class="n">dow</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">evenum</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dow</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dow</span><span class="p">)):</span>
            <span class="n">dow</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">_triangular</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">evenum</span> <span class="o">-</span> <span class="n">_triangular</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dow</span>


<span class="k">def</span> <span class="nf">_getAcr</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">evenum</span><span class="p">):</span>
    <span class="n">acr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">evenum</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">acr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_triangular</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">_triangular</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="p">(</span><span class="n">evenum</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">acr</span><span class="p">)):</span>
            <span class="n">acr</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">acr</span><span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">acr</span>


<span class="k">def</span> <span class="nf">_triangular</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculate sum of triangle with base N, </span>
<span class="sd">    see http://en.wikipedia.org/wiki/Triangular_number</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_getClustDict</span><span class="p">(</span><span class="n">linkup</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    get pd series that will define the base events in each cluster </span>
<span class="sd">    (including intermediate clusters)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">clusdict</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">inds</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">linkup</span><span class="p">)):</span>
        <span class="n">ind1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">linkup</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
        <span class="n">ind2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">linkup</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ind3</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">linkup</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">clusdict</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clusdict</span><span class="p">[</span><span class="n">ind2</span><span class="p">],</span> <span class="n">clusdict</span><span class="p">[</span><span class="n">ind3</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">clusdict</span>


<span class="k">def</span> <span class="nf">_ensureUnique</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cxdf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make sure each coeficient is unique so it can be used as a key to </span>
<span class="sd">    reference time lags, if not unique perturb slightly</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">se</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span>
    <span class="n">dups</span> <span class="o">=</span> <span class="n">se</span><span class="p">[</span><span class="n">se</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()]</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">dups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Duplicates found in correlation coefficients,&#39;</span>
               <span class="s1">&#39;perturbing slightly to get unique values&#39;</span><span class="p">)</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warning&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dups</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">se</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="o">.</span><span class="mi">00001</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">())</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">dups</span> <span class="o">=</span> <span class="n">se</span><span class="p">[</span><span class="n">se</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;cannot make Coeficients unique, killing program&#39;</span>
            <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if the cx has been perturbed update cxdf</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cxdf</span><span class="p">)):</span>
            <span class="n">sindex</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">tri1</span> <span class="o">=</span> <span class="n">_triangular</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cxdf</span><span class="p">))</span>
            <span class="n">tri2</span> <span class="o">=</span> <span class="n">_triangular</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cxdf</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
            <span class="n">tri3</span> <span class="o">=</span> <span class="n">_triangular</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cxdf</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">cxdf</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">sindex</span><span class="p">:]</span> <span class="o">=</span> <span class="n">cx</span><span class="p">[</span><span class="n">tri1</span> <span class="o">-</span> <span class="n">tri2</span><span class="p">,</span> <span class="n">tri1</span> <span class="o">-</span> <span class="n">tri3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">se</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">cxdf</span>


<span class="k">def</span> <span class="nf">_makeCC2LagMap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lags</span><span class="p">):</span>
    <span class="n">LS</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LS</span>


<span class="k">def</span> <span class="nf">_loadStream</span><span class="p">(</span><span class="n">fetcher</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="p">,</span> <span class="n">decimate</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span>
                <span class="n">temkey</span><span class="p">,</span> <span class="n">stakey</span><span class="p">,</span> <span class="n">enforceOrigin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">phases</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    loads all traces into stream object and applies filters and trims</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">StreamDict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Initialize dictionary for stream objects</span>
    <span class="n">channelDict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">STlens</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">trLen</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># trace length</span>
    <span class="n">allzeros</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># empty list to stuff all zero keys to remove later</span>
    <span class="n">csta</span> <span class="o">=</span> <span class="n">stakey</span><span class="p">[</span><span class="n">stakey</span><span class="o">.</span><span class="n">STATION</span> <span class="o">==</span> <span class="n">station</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># load waveforms</span>
    <span class="k">for</span> <span class="n">st</span><span class="p">,</span> <span class="n">evename</span> <span class="ow">in</span> <span class="n">fetcher</span><span class="o">.</span><span class="n">getTemData</span><span class="p">(</span><span class="n">temkey</span><span class="p">,</span> <span class="n">csta</span><span class="p">,</span> <span class="n">trim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">trim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                          <span class="n">returnName</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">phases</span><span class="o">=</span><span class="n">phases</span><span class="p">):</span>

        <span class="n">st</span> <span class="o">=</span> <span class="n">_applyFilter</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">decimate</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">st</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># skip if stream empty</span>
        <span class="n">tem</span> <span class="o">=</span> <span class="n">temkey</span><span class="p">[</span><span class="n">temkey</span><span class="o">.</span><span class="n">NAME</span> <span class="o">==</span> <span class="n">evename</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tem</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># in theory this should never happen</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> not in template key, skipping&#39;</span>
            <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">originTime</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="n">tem</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">TIME</span><span class="p">)</span>
        <span class="n">Nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st</span><span class="p">]))</span>  <span class="c1"># get number of channels</span>
        <span class="k">if</span> <span class="n">Nc</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> on </span><span class="si">%s</span><span class="s1"> is fractured or channels are missing, consider &#39;</span>
                   <span class="s1">&#39;setting fillZeros to True in ClusterStream to try to &#39;</span>
                   <span class="s1">&#39;make it usable, skipping&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">evename</span><span class="p">,</span> <span class="n">station</span><span class="p">)</span>
            <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">enforceOrigin</span><span class="p">:</span>  <span class="c1"># if the waveforms should start at the origin</span>
            <span class="n">st</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">originTime</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">StreamDict</span><span class="p">[</span><span class="n">evename</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
        <span class="n">channelDict</span><span class="p">[</span><span class="n">evename</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st</span><span class="p">]</span>
        <span class="n">pros</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;processing&#39;</span><span class="p">]</span>
        <span class="n">sr</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="n">statsdi</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;processing&#39;</span><span class="p">:</span> <span class="n">pros</span><span class="p">,</span> <span class="s1">&#39;sampling_rate&#39;</span><span class="p">:</span> <span class="n">sr</span><span class="p">,</span> <span class="s1">&#39;starttime&#39;</span><span class="p">:</span> <span class="n">start</span><span class="p">,</span>
                   <span class="s1">&#39;Nc&#39;</span><span class="p">:</span> <span class="n">Nc</span><span class="p">}</span>
        <span class="n">stats</span><span class="p">[</span><span class="n">evename</span><span class="p">]</span> <span class="o">=</span> <span class="n">statsdi</span>  <span class="c1"># put stats in dict</span>
        <span class="n">totalLength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st</span><span class="p">]):</span>
            <span class="n">allzeros</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">evename</span><span class="p">)</span>
        <span class="n">trLen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">totalLength</span><span class="p">)</span>
        <span class="n">STlens</span><span class="p">[</span><span class="n">evename</span><span class="p">]</span> <span class="o">=</span> <span class="n">totalLength</span>

    <span class="n">mlen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">trLen</span><span class="p">)</span>
    <span class="n">keysToRemove</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">StreamDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">STlens</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mlen</span> <span class="o">*</span> <span class="o">.</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keysToRemove</span><span class="p">:</span>  <span class="c1"># Remove fractured or very short waveforms</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is fractured or missing data, removing&#39;</span> <span class="o">%</span> <span class="n">key</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warning&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">StreamDict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">channelDict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">allzeros</span><span class="p">):</span>  <span class="c1"># remove waveforms with channels filled with 0s</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> has at least one channel that is all zeros, deleting&#39;</span> <span class="o">%</span> <span class="n">key</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warning&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">StreamDict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">channelDict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">stats</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">StreamDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Less than 2 events survived preprocessing for station&#39;</span>
               <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> Check input parameters, especially trim&#39;</span> <span class="o">%</span> <span class="n">station</span><span class="p">)</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warning&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">evlist</span> <span class="o">=</span> <span class="n">StreamDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">evlist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="c1"># if &#39;IMU&#39; in station:</span>
    <span class="k">return</span> <span class="n">StreamDict</span><span class="p">,</span> <span class="n">evlist</span><span class="p">,</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">stats</span>


<div class="viewcode-block" id="multiplex"><a class="viewcode-back" href="../../detex.html#detex.construct.multiplex">[docs]</a><span class="k">def</span> <span class="nf">multiplex</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">Nc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trimTolerance</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">returnlist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">retst</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiplex an obspy stream object</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    st : instance of obspy stream</span>
<span class="sd">        The stream containing the data to multiplex. </span>
<span class="sd">    Nc : None or int</span>
<span class="sd">        if not None the number of channels in stream, else try to determine</span>
<span class="sd">    trimTolerance : int</span>
<span class="sd">        The number of samples each channel can vary before being rejected</span>
<span class="sd">    Template : bool</span>
<span class="sd">        If True st is a template waveform, therefore an exception will be </span>
<span class="sd">        raised if trimeTolerance is exceeded</span>
<span class="sd">    returnlist : bool</span>
<span class="sd">        If true also return np array of un-multiplexed data as a list</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    ------</span>
<span class="sd">    list with multiplexed data and other desired waveforms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Nc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">Nc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># If only one channel do nothing</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">chans</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st</span><span class="p">]</span>  <span class="c1"># Data on each channel</span>
        <span class="n">minlen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">chans</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">minlen</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">minlen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">trimTolerance</span><span class="p">:</span>
            <span class="n">netsta</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">network</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span>
            <span class="n">utc1</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">utc2</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Channel lengths are not within </span><span class="si">%d</span><span class="s1"> on </span><span class="si">%s</span><span class="s1"> from </span><span class="si">%s</span><span class="s1"> to </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                   <span class="p">(</span><span class="n">trimTolerance</span><span class="p">,</span> <span class="n">netsta</span><span class="p">,</span> <span class="n">utc1</span><span class="p">,</span> <span class="n">utc2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">template</span><span class="p">:</span>
                <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">+</span> <span class="s1">&#39; trimming to shortest channel&#39;</span>
                <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warning&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">trimDim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minlen</span><span class="p">)</span>  <span class="c1"># trim to smalles dimension</span>
                <span class="n">chansTrimed</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[:</span><span class="n">trimDim</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">chans</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">max</span><span class="p">(</span><span class="n">minlen</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">minlen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if all channels not equal lengths</span>
            <span class="n">trimDim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minlen</span><span class="p">)</span>
            <span class="n">chansTrimed</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[:</span><span class="n">trimDim</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">chans</span><span class="p">]</span>  <span class="c1"># trim to shortest</span>
        <span class="k">elif</span> <span class="nb">max</span><span class="p">(</span><span class="n">minlen</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">minlen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if chan lengths are exactly equal</span>
            <span class="n">chansTrimed</span> <span class="o">=</span> <span class="n">chans</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">chansTrimed</span><span class="p">))</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">C1</span><span class="p">]</span>  <span class="c1"># init output list</span>
    <span class="k">if</span> <span class="n">returnlist</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">retst</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span></div>


<span class="k">def</span> <span class="nf">_applyFilter</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">decimate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;double&#39;</span><span class="p">,</span> <span class="n">fillZeros</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a filter, decimate, and trim to even start/end times </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">st</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;_applyFilter got a stream with 0 length&#39;</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
    <span class="n">st</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">st1</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>  <span class="c1"># cast into single</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">tr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
            <span class="n">st</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">nc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st</span><span class="p">]))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>  <span class="c1"># if data is fragmented only keep largest chunk</span>
        <span class="k">if</span> <span class="n">fillZeros</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">_mergeChannelsFill</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">_mergeChannels</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">sta</span> <span class="o">=</span> <span class="n">st1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span>
        <span class="n">stime</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">st1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Stream is too fractured around </span><span class="si">%s</span><span class="s1"> on </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">stime</span><span class="p">),</span> <span class="n">sta</span><span class="p">)</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="c1"># st1.write(&#39;failed_merge-%s-%s.pkl&#39;%(sta, stime), &#39;pickle&#39;)</span>
        <span class="c1"># assert len(st) == len(nc)</span>
    <span class="k">if</span> <span class="n">decimate</span><span class="p">:</span>
        <span class="n">st</span><span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="n">decimate</span><span class="p">)</span>

    <span class="n">startTrim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st</span><span class="p">])</span>
    <span class="n">endTrim</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">startTrim</span> <span class="o">&gt;</span> <span class="n">endTrim</span><span class="p">:</span>  <span class="c1"># return empty string if chans dont overlap</span>
        <span class="k">return</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
    <span class="n">st</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">startTrim</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">endTrim</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">st</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">st</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s1">&#39;bandpass&#39;</span><span class="p">,</span> <span class="n">freqmin</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqmax</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                  <span class="n">corners</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">zerophase</span><span class="o">=</span><span class="n">filt</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">st</span>


<span class="k">def</span> <span class="nf">_mergeChannels</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to find longest continuous data chunck and discard the rest</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st1</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">st1</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st1</span><span class="p">])</span>
    <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st1</span><span class="p">])</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">st1</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">end</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># if stream too factured end is larger than start</span>
        <span class="k">return</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
    <span class="n">ar_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st1</span><span class="p">])</span>

    <span class="n">ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ar_len</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">st1</span><span class="p">:</span>
        <span class="n">ar</span> <span class="o">*=</span> <span class="n">tr</span><span class="o">.</span><span class="n">data</span>
    <span class="n">trace</span> <span class="o">=</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Trace</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">ar</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ar</span><span class="p">))</span>
    <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="o">=</span> <span class="n">start</span>
    <span class="n">trace</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">st1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sampling_rate</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ar</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">st2</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obspy</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">endtime</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">st2</span><span class="p">])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">])</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;stop&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>
        <span class="n">max_dur</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">duration</span> <span class="o">==</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">st</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">max_dur</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">max_dur</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st1</span>
    <span class="k">return</span> <span class="n">st</span>


<span class="k">def</span> <span class="nf">_mergeChannelsFill</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
    <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">st</span>


<span class="k">def</span> <span class="nf">_checkClusterInputs</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">trim</span><span class="p">,</span> <span class="n">decimate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check a few key input parameters to make sure everything is kosher</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">filt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># check filt</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;filt must either be None (no filter) or a len 4 list or tuple&#39;</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="s1">&#39;double&#39;</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>  <span class="c1"># check dtype</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;dype must be either &quot;double&quot; or &quot;single&quot; not </span><span class="si">%s</span><span class="s1">, setting to </span><span class="se">\</span>
<span class="s1">                double&#39;</span> <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;double&#39;</span>
        <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">trim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># check trim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trim</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Trim must be a list or tuple of length 2&#39;</span>
            <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">pri</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">trim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">trim</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Invalid trim parameters&#39;</span>
                <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">decimate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decimate</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;decimate must be an int&#39;</span>
            <span class="n">detex</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="ne">TypeError</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">detex</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../detex.html">detex package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../detex.html">detex</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Derrick Chambers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>